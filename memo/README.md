#### tokenize.c
入力された文字列をトークンに分割し種類ごとに分ける

##### equal関数
・Tokenオブジェクトのポインタtok
・文字列op

tokのlocと、opのメモリ領域の文字列が同じかどうかを判断している

トークンtokが、指定された文字列opと完全に一致しているかどうか

tok->locは、トークンの開始位置を表す

ex:
```c
Token token;
token.loc = "==";
token.len = 2;

bool result1 = equal(&token, "=="); // true
bool result2 = equal(&token, "=");  // false
bool result3 = equal(&token, "==="); // false
```

##### skip関数
現在のトークンが一致する場合は次のトークンを返す
一致しない場合はエラーを返す

この関数で、文法を定義している
ソースコードが期待される文法に従って記述されているかを確認している

だから、static関数ではない
parse.cの中で呼び出されている


##### new_token関数
呼び出されるごとに、kind start endを使用し新しいTokenを作成する

1. calloc関数で、Token構造体のサイズに合わせてメモリ領域を確保
2. 確保されたメモリ領域のアドレスをtokというポインタ変数に代入
3. tok->kindに、kindを代入し、トークンの種類をセット
4. tok->locに、startを入れ、文字列の開始位置をセット
5. tok->lenに、end - startでトークンの長さをセット


##### tokenize関数
+*/-(){}などの解析はここで行わず、トークンの長さを取得しそのトークンを
トークンリストに追加している

トークンがどのような演算子であるかどうかは、ここでは
解析されていない



#### parse.c
分割されたトークンごとに、解析を行い、
それを抽象構文木（AST）に変換を行う

-----------------------------------------------------

・new_node, new_binary, new_unary, new_num：
ASTノードを生成するためのヘルパ関数

・expr：
式を解析するためのエントリーポイント

・equality, relational, add, mul, unary, primary：
特定の演算子や式の部分を解析するための関数。これらは演算子の優先順序を考慮して階層的に定義されている

・parse：
トークンストリームを受け取り、ASTを生成するための関数。この関数はexprを呼び出してASTのルートノードを生成する

-----------------------------------------------------